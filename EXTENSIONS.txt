Options to expand beyond the current scope of Amazon.com mostly include adding additional regular expressions or changing existing regular expressions to handle specific cases. In parse_functions.js, for example, getinfo() could be fed an additional argument or two to pick from a table that assigns regex_array a particular value specific to the website that's being searched and the target subject. 
This set of tables would need to be placed elsewhere, or more likely drawn from a clientside file and turned into an array for use. There are also a few hardcoded functions that don't work outside of the Amazon domain, such as the Product class's doppelganger(). These would need to take additional arguments as well. 
My suggestion for this implementation, instead of passing an argument every time that context matters, is to create a special initialization function. This function would check the arguments passed in against known regexes and, if they are found, add the values to a universally accessable array that can be called on by any of the functions. Said array would never be altered after initialization in order to ensure consistency. 
A personal choice for this array is process.argv, as it, like any array in Javascript, can be dynamically allocated, and as a process value is held by all parts of the overall program instead of within a function context. It may in some cases be bad practice or a vector for error to edit process.argv, however, so this is not a certain answer.

Products beyond books will require regular expression alterations for reasons similar to non-Amazon websites, as well as a modification to the Product class. This makes the creation of such a constructor slightly difficult, but not impossible. All that needs to be done is to make sure only the data appropriate for a particular type of product is searched for, assigned, and checked by the program. JSON.stringify does not print undefined values, which means any values not use must simply be kept undefined. A bouncy ball might have a name instead of a title, but it will have a price, a weight, and a sourceURL just like a hardcover book would. 
Looking at the Amazon listing of products, the format of price and weight also varies across departments, as expected. However, there also must be accounting for false positives as well: 'https://www.amazon.com/dp/B07FRLGPV3/' grants no information prior to following the link whether the product in question is a book (it isn't). Secondary verification for this fact must be added accordingly- searching for telltale text in the title or elsewhere in the page might yield results. It's entirely possible the crawler will work with a site that doesn't have such text: For crawlers where chasing after the wind could increase runtime exponentially or result in junk values, there must be a decision as to at what threshold false positives should be dropped or taken.

Another possible extension is to allow more options for retries or alternate entry paths: For example, if the initial scraper request provides no match results, instead of letting it be, the scraper could check to see if this is the first attempt (via a variable or the counter compared to the filter size) and restart the scraper with a different baseweb value. That value could be assigned via the initialization setup, and allow two or three options before surrendering.
In addition, if an XHTTP request is dropped during site_to_JSON but it is not the final site in the array, there could be a check to verify the process could continue. If it comes up true, a shift in values to account for the counter change (or a contingency in place to ensure that the array values left uninitialized do not cause errors) would allow continued recursion of site_to_JSON if the most recent request was not the final one. This was not currently implemented in order to prevent breakdown of existing functions. 
Further extensions will likely require additional files and the splitting of the main file into two or more files, to reduce clutter and focus on each function's individual contribution.
