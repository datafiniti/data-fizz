// what this module does
	// input  => array of json objects with book data
	// output => arrange the json objects with book data into the least number of boxes with a max weight of 10lb
	// process => arranging books into least number of boxes
var shipping = require('shipping');

function arrange(books,callback){

	// array that will hold the least amount of boxes(of capacity 10lb) needed to pack all the books
	var leastBoxes = [];

	// each box has contents/books
	var contents = [];


	// merge sort to sort the books by weight nonincreasingly

	function mergeSort(arr){
	    if(arr.length < 2){
	        return arr;
	    }
	    var middle = parseInt(arr.length/2);
	    var left   = arr.slice(0, middle);
	    var right  = arr.slice(middle, arr.length);
	    
	    return merge(mergeSort(left), mergeSort(right));
	}

	function merge(left,right){
	    var result = [];
	 
	    while (left.length && right.length) {
	        if (parseFloat(left[0].weight.split(" ")[0]) >= parseFloat(right[0].weight.split(" ")[0])) {
	            result.push(left.shift());
	        } else {
	            result.push(right.shift());
	        }
	    }
	 
	    while (left.length){
	        result.push(left.shift());
	 	}

	    while (right.length){
	        result.push(right.shift());
	 	}

	    return result;
	}

	// Keep all the boxes open until the end. If a book doesnt fit in a box, try checking for space in the boxes before it. Else, make a new box
	
	// this technique is called next fit decreasing
	function startArranging(books){
		var contents = [];
		var boxWeight = [];
		var j=0;

		for(var i=0;i<books.length;i++){
			var bookWeight = parseFloat(books[i].weight.split(" ")[0].trim());
		    
		    if(i===0){
		        contents[j] = [];
		        contents[j].push(books[i]);
		        boxWeight[j] = bookWeight;
		    }else if(bookWeight>(10-boxWeight[j])){
		        for(var k=0;k<=boxWeight.length; k++){
		            if(bookWeight <= (10-boxWeight[k])){
		                contents[k].push(books[i]);
		                boxWeight[k] += bookWeight;
		                break;
		            }else if(k==boxWeight.length){
		                j++;
		                contents[j] = [];
		                contents[j].push(books[i]);
		                boxWeight[j] = bookWeight;
		                break;
		            }
		        }
		    }else if(bookWeight===(10-boxWeight[j])){
		        contents[j].push(books[i]);
		        boxWeight[j] += bookWeight;
		    }else if(bookWeight<(10-boxWeight[j])){
		        contents[j].push(books[i]);
		        boxWeight[j] += bookWeight;
		    }

		    if(i==books.length-1){
		    	showResults(contents,boxWeight);
		    }
		}
	}

	// put contents into box and put boxes into an array
	function showResults(contents,boxWeight){
		for(var i=0;i<=contents.length;i++){
			if(i<contents.length){
				leastBoxes.push(new shipping.box(i+1,boxWeight[i],contents[i]));
			}else{
				// return least boxes array
				callback(JSON.stringify(leastBoxes));
			}
		}
	}

	startArranging(mergeSort(books));
}

module.exports = {
	arrange: arrange
}
