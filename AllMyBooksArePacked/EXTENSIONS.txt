1) By Including an HTML Interface, HTML files that are not part of the Amazon.com domain can still be parsed by the Parser.java class. By implementing this interface, additional ***Parser.java classes can be added for each domain. Additionally, if there is a similar pattern across domains, a more generic class could be added that scrapes data from all domains for which the CSS patterns hold.
2) Additional products can be handled by creating additional classes that implement the Product interface. Products are required to have a price and weight, but any arbitrary type and number of additional attributes can be processed and formatted to JSON using the getAttrs() method. Boxes and Factories (class to handle Collections of Boxes) all deal with Products, not Books.
3) The sorting algorithm implemented is the FirstFit bin sorting algorithm. It begins by sorting the list of Products by descending weight, and then inserting them one at a time into the first box they fit into. If no such box exists, a new box is created. The algorithm ensures that, in the worst case, no more than twice the optimal number boxes will be used, as any box that is at least half filled will be added to before a new box is created (A tighter bound of 11/9 * Optimal can be proven with rigorous set theory). In order to optimize this implementation, the Factory class was made abstract and then extended by two different classes with different implementations. The first stores the boxes in a List, which has worse case run time O(N^2) (in the case that each product must open a new box at the end of the list). The second uses a TreeMap to map boxes to the available space in each box. They keys (available weight) are sorted in a balanced BST, and the Products are thus put into the box with the least available space in which it will still fit. While messier, and requiring slightly more memory overhead (Boxes must be removed and re-inserted when mutated to preserve balance, and Lists must be used as values to accommodate multiple boxes with the same space remaining), for large number of Products, the time complexity only grows as O(NlogN), because it takes at worst logN time to insert a new Product into the BST, which is done N times (also NlogN to sort the list in the beginning).
